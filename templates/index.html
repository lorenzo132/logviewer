{% extends "base.html" %}
{% block content %}

<main>
<div class="vertical-align-middle center container">
        <h1 class="animated jackInTheBox header" id='dashbots'>Logviewer</h1>
        <h5 class="header col s12 light grey-text">This site is used to display Modmail log entries.</h5>
        <br>
        <div class="row center">
            <a href="https://github.com/kyb3r/modmail" class="btn waves-effect my-button">Github</a>
            <a href="https://github.com/kyb3r/modmail/wiki" class="btn waves-effect my-button">Wiki</a>
            <a href="https://patreon.com/kyber" class="btn waves-effect my-button">Patreon</a>
            <a href="https://discord.gg/etJNHCQ" class="btn waves-effect my-button">Support Server</a>
            <iframe src="https://bgmusic.discord.gold/public/background_radio_sites/embed" frameborder="0" allowtransparency="true" style="width: 100%; min-height: 150px; border: 0;"></iframe>
            <br>
        </div>
    </div>
</div>
</main>
<body>
     <canvas id="c" width="10" height="1013" style="width: 100%; height: 100%; border:0px solid;"></canvas>
    <script type="text/javascript">
        "use strict";
        const canvas = document.getElementsByTagName("canvas")[0];
        canvas.width = canvas.clientWidth, canvas.height = canvas.clientHeight, Array.prototype.getRandom = function() {
            return this[Math.floor(Math.random() * this.length)]
        };
        let splatColors = [{
                r: 0,
                g: .15,
                b: 0
            }],
            config = {
                SIM_RESOLUTION: 256,
                DYE_RESOLUTION: 1024,
                DENSITY_DISSIPATION: .97,
                VELOCITY_DISSIPATION: .98,
                PRESSURE_DISSIPATION: .8,
                PRESSURE_ITERATIONS: 20,
                CURL: 30,
                SPLAT_RADIUS: .3,
                SHADING: !0,
                COLORFUL: !0,
                PAUSED: !1,
                BACK_COLOR: {
                    r: 0,
                    g: 0,
                    b: 0
                },
                TRANSPARENT: !1,
                BLOOM: !0,
                BLOOM_ITERATIONS: 8,
                BLOOM_RESOLUTION: 256,
                BLOOM_INTENSITY: .8,
                BLOOM_THRESHOLD: .6,
                BLOOM_SOFT_KNEE: .7,
                POINTER_COLOR: [{
                    r: 0,
                    g: .15,
                    b: 0
                }],
                SOUND_SENSITIVITY: .25,
                AUDIO_RESPONSIVE: !0,
                FREQ_RANGE: 8,
                FREQ_RANGE_START: 0
            };

        function indexOfMax(e) {
            if (0 === e.length) return -1;
            for (var r = e[0], n = 0, t = 1; t < e.length; t++) e[t] > r && (n = t, r = e[t]);
            return n
        }

        function pointerPrototype() {
            this.id = -1, this.x = 0, this.y = 0, this.dx = 0, this.dy = 0, this.down = !1, this.moved = !1, this.color = [30, 0, 300]
        }
        document.addEventListener("DOMContentLoaded", () => {
            window.wallpaperPropertyListener = {
                applyUserProperties: e => {
                    if (e.bloom_intensity && (config.BLOOM_INTENSITY = e.bloom_intensity.value), e.bloom_threshold && (config.BLOOM_THRESHOLD = e.bloom_threshold.value), e.colorful && (config.COLORFUL = e.colorful.value), e.density_diffusion && (config.DENSITY_DISSIPATION = e.density_diffusion.value), e.enable_bloom && (config.BLOOM = e.enable_bloom.value), e.paused && (config.PAUSED = e.paused.value), e.pressure_diffusion && (config.PRESSURE_DISSIPATION = e.pressure_diffusion.value), e.shading && (config.SHADING = e.shading.value), e.splat_radius && (config.SPLAT_RADIUS = e.splat_radius.value), e.velocity_diffusion && (config.VELOCITY_DISSIPATION = e.velocity_diffusion.value), e.vorticity && (config.CURL = e.vorticity.value), e.sound_sensitivity && (config.SOUND_SENSITIVITY = e.sound_sensitivity.value), e.audio_responsive && (config.AUDIO_RESPONSIVE = e.audio_responsive.value), e.simulation_resolution && (config.SIM_RESOLUTION = e.simulation_resolution.value, initFramebuffers()), e.dye_resolution && (config.DYE_RESOLUTION = e.dye_resolution.value, initFramebuffers()), e.splat_color && (splatColors[0] = rgbToPointerColor(e.splat_color.value)), e.splat_color_2 && (splatColors[1] = rgbToPointerColor(e.splat_color_2.value)), e.splat_color_3 && (splatColors[2] = rgbToPointerColor(e.splat_color_3.value)), e.splat_color_4 && (splatColors[3] = rgbToPointerColor(e.splat_color_4.value)), e.splat_color_5 && (splatColors[4] = rgbToPointerColor(e.splat_color_5.value)), e.background_color) {
                        let r = e.background_color.value.split(" "),
                            n = Math.floor(255 * r[0]),
                            t = Math.floor(255 * r[1]),
                            i = Math.floor(255 * r[2]);
                        document.body.style.backgroundColor = `rgb(${n}, ${t}, ${i})`, config.BACK_COLOR.r = n, config.BACK_COLOR.g = t, config.BACK_COLOR.b = i
                    }
                    e.more_colors && !e.more_colors.value ? config.POINTER_COLOR = [splatColors[0]] : e.more_colors && e.more_colors.value && (config.POINTER_COLOR = splatColors), e.use_background_image && (config.TRANSPARENT = e.use_background_image.value), e.background_image && (canvas.style.backgroundImage = `url("file:///${e.background_image.value}")`), e.repeat_background && (canvas.style.backgroundRepeat = e.repeat_background.value ? "repeat" : "no-repeat"), e.background_image_size && (canvas.style.backgroundSize = e.background_image_size.value), e.frequency_range && (config.FREQ_RANGE = e.frequency_range.value, config.FREQ_RANGE + config.FREQ_RANGE_START > 61 && (config.FREQ_RANGE_START = 62 - config.FREQ_RANGE)), e.frequency_range_start && (config.FREQ_RANGE + e.frequency_range_start.value > 61 ? config.FREQ_RANGE_START = 62 - config.FREQ_RANGE : config.FREQ_RANGE_START = e.frequency_range_start.value)
                }
            }
        });
        let pointers = [],
            splatStack = [],
            bloomFramebuffers = [];
        pointers.push(new pointerPrototype);
        const {
            gl: gl,
            ext: ext
        } = getWebGLContext(canvas);

        function getWebGLContext(e) {
            const r = {
                alpha: !0,
                depth: !1,
                stencil: !1,
                antialias: !1,
                preserveDrawingBuffer: !1
            };
            let n = e.getContext("webgl2", r);
            const t = !!n;
            let i, o;
            t || (n = e.getContext("webgl", r) || e.getContext("experimental-webgl", r)), t ? (n.getExtension("EXT_color_buffer_float"), o = n.getExtension("OES_texture_float_linear")) : (i = n.getExtension("OES_texture_half_float"), o = n.getExtension("OES_texture_half_float_linear")), n.clearColor(0, 0, 0, 1);
            const a = t ? n.HALF_FLOAT : i.HALF_FLOAT_OES;
            let l, g, u;
            return t ? (l = getSupportedFormat(n, n.RGBA16F, n.RGBA, a), g = getSupportedFormat(n, n.RG16F, n.RG, a), u = getSupportedFormat(n, n.R16F, n.RED, a)) : (l = getSupportedFormat(n, n.RGBA, n.RGBA, a), g = getSupportedFormat(n, n.RGBA, n.RGBA, a), u = getSupportedFormat(n, n.RGBA, n.RGBA, a)), {
                gl: n,
                ext: {
                    formatRGBA: l,
                    formatRG: g,
                    formatR: u,
                    halfFloatTexType: a,
                    supportLinearFiltering: o
                }
            }
        }

        function getSupportedFormat(e, r, n, t) {
            if (!supportRenderTextureFormat(e, r, n, t)) switch (r) {
                case e.R16F:
                    return getSupportedFormat(e, e.RG16F, e.RG, t);
                case e.RG16F:
                    return getSupportedFormat(e, e.RGBA16F, e.RGBA, t);
                default:
                    return null
            }
            return {
                internalFormat: r,
                format: n
            }
        }

        function supportRenderTextureFormat(e, r, n, t) {
            let i = e.createTexture();
            e.bindTexture(e.TEXTURE_2D, i), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texImage2D(e.TEXTURE_2D, 0, r, 4, 4, 0, n, t, null);
            let o = e.createFramebuffer();
            return e.bindFramebuffer(e.FRAMEBUFFER, o), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, i, 0), e.checkFramebufferStatus(e.FRAMEBUFFER) == e.FRAMEBUFFER_COMPLETE
        }

        function startGUI() {
            var e = new dat.GUI({
                width: 300
            });
            e.add(config, "SIM_RESOLUTION", {
                32: 32,
                64: 64,
                128: 128,
                256: 256
            }).name("sim resolution").onFinishChange(initFramebuffers), e.add(config, "DYE_RESOLUTION", {
                128: 128,
                256: 256,
                512: 512,
                1024: 1024
            }).name("dye resolution").onFinishChange(initFramebuffers), e.add(config, "DENSITY_DISSIPATION", .9, 1).name("density diffusion"), e.add(config, "VELOCITY_DISSIPATION", .9, 1).name("velocity diffusion"), e.add(config, "PRESSURE_DISSIPATION", 0, 1).name("pressure diffusion"), e.add(config, "CURL", 0, 50).name("vorticity").step(1), e.add(config, "SPLAT_RADIUS", .01, 1).name("splat radius"), e.add(config, "SHADING").name("shading"), e.add(config, "COLORFUL").name("colorful"), e.add(config, "PAUSED").name("paused").listen(), e.add({
                fun: () => {
                    splatStack.push(parseInt(20 * Math.random()) + 5)
                }
            }, "fun").name("Random splats");
            let r = e.addFolder("Bloom");
            r.add(config, "BLOOM").name("enabled"), r.add(config, "BLOOM_INTENSITY", .1, 2).name("intensity"), r.add(config, "BLOOM_THRESHOLD", 0, 1).name("threshold");
            let n = e.addFolder("Capture");
            n.addColor(config, "BACK_COLOR").name("background color"), n.add(config, "TRANSPARENT").name("transparent"), n.add({
                fun: captureScreenshot
            }, "fun").name("take screenshot");
            let t = e.add({
                fun: () => {
                    window.open("https://github.com/PavelDoGreat/WebGL-Fluid-Simulation")
                }
            }, "fun").name("Github");
            t.__li.className = "cr function bigFont", t.__li.style.borderLeft = "3px solid #8C8C8C";
            let i = document.createElement("span");
            t.domElement.parentElement.appendChild(i), i.className = "icon github";
            let o = e.add({
                fun: () => {
                    window.open("https://twitter.com/PavelDoGreat")
                }
            }, "fun").name("Twitter");
            o.__li.className = "cr function bigFont", o.__li.style.borderLeft = "3px solid #8C8C8C";
            let a = document.createElement("span");
            o.domElement.parentElement.appendChild(a), a.className = "icon twitter";
            let l = e.add({
                fun: () => {
                    window.open("https://discordapp.com/invite/CeqZDDE")
                }
            }, "fun").name("Discord");
            l.__li.className = "cr function bigFont", l.__li.style.borderLeft = "3px solid #8C8C8C";
            let g = document.createElement("span");
            l.domElement.parentElement.appendChild(g), g.className = "icon discord";
            let u = e.add({
                fun: () => {
                    window.open("http://onelink.to/5b58bn")
                }
            }, "fun").name("Check out new improved version");
            u.__li.className = "cr function appBigFont", u.__li.style.borderLeft = "3px solid #00FF7F";
            let c = document.createElement("span");
            u.domElement.parentElement.appendChild(c), c.className = "icon app", isMobile() && e.close()
        }

        function captureScreenshot() {
            colorProgram.bind(), gl.uniform4f(colorProgram.uniforms.color, 0, 0, 0, 1), blit(density.write.fbo), render(density.write.fbo), gl.bindFramebuffer(gl.FRAMEBUFFER, density.write.fbo);
            let e = dyeWidth * dyeHeight * 4,
                r = new Float32Array(e);
            gl.readPixels(0, 0, dyeWidth, dyeHeight, gl.RGBA, gl.FLOAT, r);
            let n = new Uint8Array(e),
                t = 0;
            for (let e = dyeHeight - 1; e >= 0; e--)
                for (let i = 0; i < dyeWidth; i++) {
                    let o = e * dyeWidth * 4 + 4 * i;
                    n[o + 0] = 255 * clamp01(r[t + 0]), n[o + 1] = 255 * clamp01(r[t + 1]), n[o + 2] = 255 * clamp01(r[t + 2]), n[o + 3] = 255 * clamp01(r[t + 3]), t += 4
                }
            let i = document.createElement("canvas"),
                o = i.getContext("2d");
            i.width = dyeWidth, i.height = dyeHeight;
            let a = o.createImageData(dyeWidth, dyeHeight);
            a.data.set(n), o.putImageData(a, 0, 0);
            let l = i.toDataURL();
            downloadURI("fluid.png", l), URL.revokeObjectURL(l)
        }

        function clamp01(e) {
            return Math.min(Math.max(e, 0), 1)
        }

        function downloadURI(e, r) {
            let n = document.createElement("a");
            n.download = e, n.href = r, document.body.appendChild(n), n.click(), document.body.removeChild(n)
        }

        function isMobile() {
            return /Mobi|Android/i.test(navigator.userAgent)
        }
        isMobile() && (config.SHADING = !1), ext.supportLinearFiltering || (config.SHADING = !1, config.BLOOM = !1);
        class GLProgram {
            constructor(e, r) {
                if (this.uniforms = {}, this.program = gl.createProgram(), gl.attachShader(this.program, e), gl.attachShader(this.program, r), gl.linkProgram(this.program), !gl.getProgramParameter(this.program, gl.LINK_STATUS)) throw gl.getProgramInfoLog(this.program);
                const n = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);
                for (let e = 0; e < n; e++) {
                    const r = gl.getActiveUniform(this.program, e).name;
                    this.uniforms[r] = gl.getUniformLocation(this.program, r)
                }
            }
            bind() {
                gl.useProgram(this.program)
            }
        }

        function compileShader(e, r) {
            const n = gl.createShader(e);
            if (gl.shaderSource(n, r), gl.compileShader(n), !gl.getShaderParameter(n, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(n);
            return n
        }
        const baseVertexShader = compileShader(gl.VERTEX_SHADER, "\n    precision highp float;\n\n    attribute vec2 aPosition;\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform vec2 texelSize;\n\n    void main () {\n        vUv = aPosition * 0.5 + 0.5;\n        vL = vUv - vec2(texelSize.x, 0.0);\n        vR = vUv + vec2(texelSize.x, 0.0);\n        vT = vUv + vec2(0.0, texelSize.y);\n        vB = vUv - vec2(0.0, texelSize.y);\n        gl_Position = vec4(aPosition, 0.0, 1.0);\n    }\n"),
            clearShader = compileShader(gl.FRAGMENT_SHADER, "\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    uniform sampler2D uTexture;\n    uniform float value;\n\n    void main () {\n        gl_FragColor = value * texture2D(uTexture, vUv);\n    }\n"),
            colorShader = compileShader(gl.FRAGMENT_SHADER, "\n    precision mediump float;\n\n    uniform vec4 color;\n\n    void main () {\n        gl_FragColor = color;\n    }\n"),
            backgroundShader = compileShader(gl.FRAGMENT_SHADER, "\n    void main () {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n"),
            displayShader = compileShader(gl.FRAGMENT_SHADER, "\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uTexture;\n\n    void main () {\n        vec3 C = texture2D(uTexture, vUv).rgb;\n        float a = max(C.r, max(C.g, C.b));\n        gl_FragColor = vec4(C, a);\n    }\n"),
            displayBloomShader = compileShader(gl.FRAGMENT_SHADER, "\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uTexture;\n    uniform sampler2D uBloom;\n    uniform sampler2D uDithering;\n    uniform vec2 ditherScale;\n\n    void main () {\n        vec3 C = texture2D(uTexture, vUv).rgb;\n        vec3 bloom = texture2D(uBloom, vUv).rgb;\n        vec3 noise = texture2D(uDithering, vUv * ditherScale).rgb;\n        noise = noise * 2.0 - 1.0;\n        bloom += noise / 800.0;\n        bloom = pow(bloom.rgb, vec3(1.0 / 2.2));\n        C += bloom;\n        float a = max(C.r, max(C.g, C.b));\n        gl_FragColor = vec4(C, a);\n    }\n"),
            displayShadingShader = compileShader(gl.FRAGMENT_SHADER, "\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform sampler2D uTexture;\n    uniform vec2 texelSize;\n\n    void main () {\n        vec3 L = texture2D(uTexture, vL).rgb;\n        vec3 R = texture2D(uTexture, vR).rgb;\n        vec3 T = texture2D(uTexture, vT).rgb;\n        vec3 B = texture2D(uTexture, vB).rgb;\n        vec3 C = texture2D(uTexture, vUv).rgb;\n\n        float dx = length(R) - length(L);\n        float dy = length(T) - length(B);\n\n        vec3 n = normalize(vec3(dx, dy, length(texelSize)));\n        vec3 l = vec3(0.0, 0.0, 1.0);\n\n        float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);\n        C.rgb *= diffuse;\n\n        float a = max(C.r, max(C.g, C.b));\n        gl_FragColor = vec4(C, a);\n    }\n"),
            displayBloomShadingShader = compileShader(gl.FRAGMENT_SHADER, "\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform sampler2D uTexture;\n    uniform sampler2D uBloom;\n    uniform sampler2D uDithering;\n    uniform vec2 ditherScale;\n    uniform vec2 texelSize;\n\n    void main () {\n        vec3 L = texture2D(uTexture, vL).rgb;\n        vec3 R = texture2D(uTexture, vR).rgb;\n        vec3 T = texture2D(uTexture, vT).rgb;\n        vec3 B = texture2D(uTexture, vB).rgb;\n        vec3 C = texture2D(uTexture, vUv).rgb;\n\n        float dx = length(R) - length(L);\n        float dy = length(T) - length(B);\n\n        vec3 n = normalize(vec3(dx, dy, length(texelSize)));\n        vec3 l = vec3(0.0, 0.0, 1.0);\n\n        float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);\n        C *= diffuse;\n\n        vec3 bloom = texture2D(uBloom, vUv).rgb;\n        vec3 noise = texture2D(uDithering, vUv * ditherScale).rgb;\n        noise = noise * 2.0 - 1.0;\n        bloom += noise / 800.0;\n        bloom = pow(bloom.rgb, vec3(1.0 / 2.2));\n        C += bloom;\n\n        float a = max(C.r, max(C.g, C.b));\n        gl_FragColor = vec4(C, a);\n    }\n"),
            bloomPrefilterShader = compileShader(gl.FRAGMENT_SHADER, "\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uTexture;\n    uniform vec3 curve;\n    uniform float threshold;\n\n    void main () {\n        vec3 c = texture2D(uTexture, vUv).rgb;\n        float br = max(c.r, max(c.g, c.b));\n        float rq = clamp(br - curve.x, 0.0, curve.y);\n        rq = curve.z * rq * rq;\n        c *= max(rq, br - threshold) / max(br, 0.0001);\n        gl_FragColor = vec4(c, 0.0);\n    }\n"),
            bloomBlurShader = compileShader(gl.FRAGMENT_SHADER, "\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform sampler2D uTexture;\n\n    void main () {\n        vec4 sum = vec4(0.0);\n        sum += texture2D(uTexture, vL);\n        sum += texture2D(uTexture, vR);\n        sum += texture2D(uTexture, vT);\n        sum += texture2D(uTexture, vB);\n        sum *= 0.25;\n        gl_FragColor = sum;\n    }\n"),
            bloomFinalShader = compileShader(gl.FRAGMENT_SHADER, "\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform sampler2D uTexture;\n    uniform float intensity;\n\n    void main () {\n        vec4 sum = vec4(0.0);\n        sum += texture2D(uTexture, vL);\n        sum += texture2D(uTexture, vR);\n        sum += texture2D(uTexture, vT);\n        sum += texture2D(uTexture, vB);\n        sum *= 0.25;\n        gl_FragColor = sum * intensity;\n    }\n"),
            splatShader = compileShader(gl.FRAGMENT_SHADER, "\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uTarget;\n    uniform float aspectRatio;\n    uniform vec3 color;\n    uniform vec2 point;\n    uniform float radius;\n\n    void main () {\n        vec2 p = vUv - point.xy;\n        p.x *= aspectRatio;\n        vec3 splat = exp(-dot(p, p) / radius) * color;\n        vec3 base = texture2D(uTarget, vUv).xyz;\n        gl_FragColor = vec4(base + splat, 1.0);\n    }\n"),
            advectionManualFilteringShader = compileShader(gl.FRAGMENT_SHADER, "\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uVelocity;\n    uniform sampler2D uSource;\n    uniform vec2 texelSize;\n    uniform vec2 dyeTexelSize;\n    uniform float dt;\n    uniform float dissipation;\n\n    vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {\n        vec2 st = uv / tsize - 0.5;\n\n        vec2 iuv = floor(st);\n        vec2 fuv = fract(st);\n\n        vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);\n        vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);\n        vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);\n        vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);\n\n        return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\n    }\n\n    void main () {\n        vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;\n        gl_FragColor = dissipation * bilerp(uSource, coord, dyeTexelSize);\n        gl_FragColor.a = 1.0;\n    }\n"),
            advectionShader = compileShader(gl.FRAGMENT_SHADER, "\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    uniform sampler2D uVelocity;\n    uniform sampler2D uSource;\n    uniform vec2 texelSize;\n    uniform float dt;\n    uniform float dissipation;\n\n    void main () {\n        vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\n        gl_FragColor = dissipation * texture2D(uSource, coord);\n        gl_FragColor.a = 1.0;\n    }\n"),
            divergenceShader = compileShader(gl.FRAGMENT_SHADER, "\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform sampler2D uVelocity;\n\n    void main () {\n        float L = texture2D(uVelocity, vL).x;\n        float R = texture2D(uVelocity, vR).x;\n        float T = texture2D(uVelocity, vT).y;\n        float B = texture2D(uVelocity, vB).y;\n\n        vec2 C = texture2D(uVelocity, vUv).xy;\n        if (vL.x < 0.0) { L = -C.x; }\n        if (vR.x > 1.0) { R = -C.x; }\n        if (vT.y > 1.0) { T = -C.y; }\n        if (vB.y < 0.0) { B = -C.y; }\n\n        float div = 0.5 * (R - L + T - B);\n        gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n    }\n"),
            curlShader = compileShader(gl.FRAGMENT_SHADER, "\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform sampler2D uVelocity;\n\n    void main () {\n        float L = texture2D(uVelocity, vL).y;\n        float R = texture2D(uVelocity, vR).y;\n        float T = texture2D(uVelocity, vT).x;\n        float B = texture2D(uVelocity, vB).x;\n        float vorticity = R - L - T + B;\n        gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\n    }\n"),
            vorticityShader = compileShader(gl.FRAGMENT_SHADER, "\n    precision highp float;\n    precision highp sampler2D;\n\n    varying vec2 vUv;\n    varying vec2 vL;\n    varying vec2 vR;\n    varying vec2 vT;\n    varying vec2 vB;\n    uniform sampler2D uVelocity;\n    uniform sampler2D uCurl;\n    uniform float curl;\n    uniform float dt;\n\n    void main () {\n        float L = texture2D(uCurl, vL).x;\n        float R = texture2D(uCurl, vR).x;\n        float T = texture2D(uCurl, vT).x;\n        float B = texture2D(uCurl, vB).x;\n        float C = texture2D(uCurl, vUv).x;\n\n        vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\n        force /= length(force) + 0.0001;\n        force *= curl * C;\n        force.y *= -1.0;\n\n        vec2 vel = texture2D(uVelocity, vUv).xy;\n        gl_FragColor = vec4(vel + force * dt, 0.0, 1.0);\n    }\n"),
            pressureShader = compileShader(gl.FRAGMENT_SHADER, "\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform sampler2D uPressure;\n    uniform sampler2D uDivergence;\n\n    vec2 boundary (vec2 uv) {\n        return uv;\n        // uncomment if you use wrap or repeat texture mode\n        // uv = min(max(uv, 0.0), 1.0);\n        // return uv;\n    }\n\n    void main () {\n        float L = texture2D(uPressure, boundary(vL)).x;\n        float R = texture2D(uPressure, boundary(vR)).x;\n        float T = texture2D(uPressure, boundary(vT)).x;\n        float B = texture2D(uPressure, boundary(vB)).x;\n        float C = texture2D(uPressure, vUv).x;\n        float divergence = texture2D(uDivergence, vUv).x;\n        float pressure = (L + R + B + T - divergence) * 0.25;\n        gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n    }\n"),
            gradientSubtractShader = compileShader(gl.FRAGMENT_SHADER, "\n    precision mediump float;\n    precision mediump sampler2D;\n\n    varying highp vec2 vUv;\n    varying highp vec2 vL;\n    varying highp vec2 vR;\n    varying highp vec2 vT;\n    varying highp vec2 vB;\n    uniform sampler2D uPressure;\n    uniform sampler2D uVelocity;\n\n    vec2 boundary (vec2 uv) {\n        return uv;\n        // uv = min(max(uv, 0.0), 1.0);\n        // return uv;\n    }\n\n    void main () {\n        float L = texture2D(uPressure, boundary(vL)).x;\n        float R = texture2D(uPressure, boundary(vR)).x;\n        float T = texture2D(uPressure, boundary(vT)).x;\n        float B = texture2D(uPressure, boundary(vB)).x;\n        vec2 velocity = texture2D(uVelocity, vUv).xy;\n        velocity.xy -= vec2(R - L, T - B);\n        gl_FragColor = vec4(velocity, 0.0, 1.0);\n    }\n"),
            blit = (() => (gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer()), gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer()), gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW), gl.vertexAttribPointer(0, 2, gl.FLOAT, !1, 0, 0), gl.enableVertexAttribArray(0), e => {
                gl.bindFramebuffer(gl.FRAMEBUFFER, e), gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0)
            }))();
        let simWidth, simHeight, dyeWidth, dyeHeight, density, velocity, divergence, curl, pressure, bloom, ditheringTexture = createTextureAsync("");
        const clearProgram = new GLProgram(baseVertexShader, clearShader),
            colorProgram = new GLProgram(baseVertexShader, colorShader),
            backgroundProgram = new GLProgram(baseVertexShader, backgroundShader),
            displayProgram = new GLProgram(baseVertexShader, displayShader),
            displayBloomProgram = new GLProgram(baseVertexShader, displayBloomShader),
            displayShadingProgram = new GLProgram(baseVertexShader, displayShadingShader),
            displayBloomShadingProgram = new GLProgram(baseVertexShader, displayBloomShadingShader),
            bloomPrefilterProgram = new GLProgram(baseVertexShader, bloomPrefilterShader),
            bloomBlurProgram = new GLProgram(baseVertexShader, bloomBlurShader),
            bloomFinalProgram = new GLProgram(baseVertexShader, bloomFinalShader),
            splatProgram = new GLProgram(baseVertexShader, splatShader),
            advectionProgram = new GLProgram(baseVertexShader, ext.supportLinearFiltering ? advectionShader : advectionManualFilteringShader),
            divergenceProgram = new GLProgram(baseVertexShader, divergenceShader),
            curlProgram = new GLProgram(baseVertexShader, curlShader),
            vorticityProgram = new GLProgram(baseVertexShader, vorticityShader),
            pressureProgram = new GLProgram(baseVertexShader, pressureShader),
            gradienSubtractProgram = new GLProgram(baseVertexShader, gradientSubtractShader);

        function initFramebuffers() {
            let e = getResolution(config.SIM_RESOLUTION),
                r = getResolution(config.DYE_RESOLUTION);
            simWidth = e.width, simHeight = e.height, dyeWidth = r.width, dyeHeight = r.height;
            const n = ext.halfFloatTexType,
                t = ext.formatRGBA,
                i = ext.formatRG,
                o = ext.formatR,
                a = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;
            density = null == density ? createDoubleFBO(dyeWidth, dyeHeight, t.internalFormat, t.format, n, a) : resizeDoubleFBO(density, dyeWidth, dyeHeight, t.internalFormat, t.format, n, a), velocity = null == velocity ? createDoubleFBO(simWidth, simHeight, i.internalFormat, i.format, n, a) : resizeDoubleFBO(velocity, simWidth, simHeight, i.internalFormat, i.format, n, a), divergence = createFBO(simWidth, simHeight, o.internalFormat, o.format, n, gl.NEAREST), curl = createFBO(simWidth, simHeight, o.internalFormat, o.format, n, gl.NEAREST), pressure = createDoubleFBO(simWidth, simHeight, o.internalFormat, o.format, n, gl.NEAREST), initBloomFramebuffers()
        }

        function initBloomFramebuffers() {
            let e = getResolution(config.BLOOM_RESOLUTION);
            const r = ext.halfFloatTexType,
                n = ext.formatRGBA,
                t = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;
            bloom = createFBO(e.width, e.height, n.internalFormat, n.format, r, t), bloomFramebuffers.length = 0;
            for (let i = 0; i < config.BLOOM_ITERATIONS; i++) {
                let o = e.width >> i + 1,
                    a = e.height >> i + 1;
                if (o < 2 || a < 2) break;
                let l = createFBO(o, a, n.internalFormat, n.format, r, t);
                bloomFramebuffers.push(l)
            }
        }

        function createFBO(e, r, n, t, i, o) {
            gl.activeTexture(gl.TEXTURE0);
            let a = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, a), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, o), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, o), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE), gl.texImage2D(gl.TEXTURE_2D, 0, n, e, r, 0, t, i, null);
            let l = gl.createFramebuffer();
            return gl.bindFramebuffer(gl.FRAMEBUFFER, l), gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, a, 0), gl.viewport(0, 0, e, r), gl.clear(gl.COLOR_BUFFER_BIT), {
                texture: a,
                fbo: l,
                width: e,
                height: r,
                attach: e => (gl.activeTexture(gl.TEXTURE0 + e), gl.bindTexture(gl.TEXTURE_2D, a), e)
            }
        }

        function createDoubleFBO(e, r, n, t, i, o) {
            let a = createFBO(e, r, n, t, i, o),
                l = createFBO(e, r, n, t, i, o);
            return {
                get read() {
                    return a
                },
                set read(e) {
                    a = e
                },
                get write() {
                    return l
                },
                set write(e) {
                    l = e
                },
                swap() {
                    let e = a;
                    a = l, l = e
                }
            }
        }

        function resizeFBO(e, r, n, t, i, o, a) {
            let l = createFBO(r, n, t, i, o, a);
            return clearProgram.bind(), gl.uniform1i(clearProgram.uniforms.uTexture, e.attach(0)), gl.uniform1f(clearProgram.uniforms.value, 1), blit(l.fbo), l
        }

        function resizeDoubleFBO(e, r, n, t, i, o, a) {
            return e.read = resizeFBO(e.read, r, n, t, i, o, a), e.write = createFBO(r, n, t, i, o, a), e
        }

        function createTextureAsync(e) {
            let r = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, r), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, new Uint8Array([255, 255, 255]));
            let n = {
                    texture: r,
                    width: 1,
                    height: 1,
                    attach: e => (gl.activeTexture(gl.TEXTURE0 + e), gl.bindTexture(gl.TEXTURE_2D, r), e)
                },
                t = new Image;
            return t.onload = (() => {
                n.width = t.width, n.height = t.height, gl.bindTexture(gl.TEXTURE_2D, r), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, t)
            }), t.src = e, n
        }
        initFramebuffers(), multipleSplats(parseInt(20 * Math.random()) + 3);
        let lastColorChangeTime = Date.now();

        function update() {
            resizeCanvas(), input(), config.PAUSED || step(.016), render(null), requestAnimationFrame(update)
        }

        function input() {
            splatStack.length > 0 && multipleSplats(splatStack.pop());
            for (let e = 0; e < pointers.length; e++) {
                const r = pointers[e];
                r.moved && (splat(r.x, r.y, r.dx, r.dy, r.color), r.moved = !1)
            }
            if (lastColorChangeTime + 100 < Date.now()) {
                lastColorChangeTime = Date.now();
                for (let e = 0; e < pointers.length; e++) {
                    pointers[e].color = config.COLORFUL ? generateColor() : config.POINTER_COLOR.getRandom()
                }
            }
        }

        function step(e) {
            gl.disable(gl.BLEND), gl.viewport(0, 0, simWidth, simHeight), curlProgram.bind(), gl.uniform2f(curlProgram.uniforms.texelSize, 1 / simWidth, 1 / simHeight), gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0)), blit(curl.fbo), vorticityProgram.bind(), gl.uniform2f(vorticityProgram.uniforms.texelSize, 1 / simWidth, 1 / simHeight), gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read.attach(0)), gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1)), gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL), gl.uniform1f(vorticityProgram.uniforms.dt, e), blit(velocity.write.fbo), velocity.swap(), divergenceProgram.bind(), gl.uniform2f(divergenceProgram.uniforms.texelSize, 1 / simWidth, 1 / simHeight), gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read.attach(0)), blit(divergence.fbo), clearProgram.bind(), gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0)), gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE_DISSIPATION), blit(pressure.write.fbo), pressure.swap(), pressureProgram.bind(), gl.uniform2f(pressureProgram.uniforms.texelSize, 1 / simWidth, 1 / simHeight), gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence.attach(0));
            for (let e = 0; e < config.PRESSURE_ITERATIONS; e++) gl.uniform1i(pressureProgram.uniforms.uPressure, pressure.read.attach(1)), blit(pressure.write.fbo), pressure.swap();
            gradienSubtractProgram.bind(), gl.uniform2f(gradienSubtractProgram.uniforms.texelSize, 1 / simWidth, 1 / simHeight), gl.uniform1i(gradienSubtractProgram.uniforms.uPressure, pressure.read.attach(0)), gl.uniform1i(gradienSubtractProgram.uniforms.uVelocity, velocity.read.attach(1)), blit(velocity.write.fbo), velocity.swap(), advectionProgram.bind(), gl.uniform2f(advectionProgram.uniforms.texelSize, 1 / simWidth, 1 / simHeight), ext.supportLinearFiltering || gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, 1 / simWidth, 1 / simHeight);
            let r = velocity.read.attach(0);
            gl.uniform1i(advectionProgram.uniforms.uVelocity, r), gl.uniform1i(advectionProgram.uniforms.uSource, r), gl.uniform1f(advectionProgram.uniforms.dt, e), gl.uniform1f(advectionProgram.uniforms.dissipation, config.VELOCITY_DISSIPATION), blit(velocity.write.fbo), velocity.swap(), gl.viewport(0, 0, dyeWidth, dyeHeight), ext.supportLinearFiltering || gl.uniform2f(advectionProgram.uniforms.dyeTexelSize, 1 / dyeWidth, 1 / dyeHeight), gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read.attach(0)), gl.uniform1i(advectionProgram.uniforms.uSource, density.read.attach(1)), gl.uniform1f(advectionProgram.uniforms.dissipation, config.DENSITY_DISSIPATION), blit(density.write.fbo), density.swap()
        }

        function render(e) {
            config.BLOOM && applyBloom(density.read, bloom), null != e && config.TRANSPARENT ? gl.disable(gl.BLEND) : (gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA), gl.enable(gl.BLEND));
            let r = null == e ? gl.drawingBufferWidth : dyeWidth,
                n = null == e ? gl.drawingBufferHeight : dyeHeight;
            if (gl.viewport(0, 0, r, n), !config.TRANSPARENT) {
                colorProgram.bind();
                let r = config.BACK_COLOR;
                gl.uniform4f(colorProgram.uniforms.color, r.r / 255, r.g / 255, r.b / 255, 1), blit(e)
            }
            if (null == e && config.TRANSPARENT && (backgroundProgram.bind(), gl.uniform1f(backgroundProgram.uniforms.aspectRatio, canvas.width / canvas.height), blit(null)), config.SHADING) {
                let e = config.BLOOM ? displayBloomShadingProgram : displayShadingProgram;
                if (e.bind(), gl.uniform2f(e.uniforms.texelSize, 1 / r, 1 / n), gl.uniform1i(e.uniforms.uTexture, density.read.attach(0)), config.BLOOM) {
                    gl.uniform1i(e.uniforms.uBloom, bloom.attach(1)), gl.uniform1i(e.uniforms.uDithering, ditheringTexture.attach(2));
                    let t = getTextureScale(ditheringTexture, r, n);
                    gl.uniform2f(e.uniforms.ditherScale, t.x, t.y)
                }
            } else {
                let e = config.BLOOM ? displayBloomProgram : displayProgram;
                if (e.bind(), gl.uniform1i(e.uniforms.uTexture, density.read.attach(0)), config.BLOOM) {
                    gl.uniform1i(e.uniforms.uBloom, bloom.attach(1)), gl.uniform1i(e.uniforms.uDithering, ditheringTexture.attach(2));
                    let t = getTextureScale(ditheringTexture, r, n);
                    gl.uniform2f(e.uniforms.ditherScale, t.x, t.y)
                }
            }
            blit(e)
        }

        function applyBloom(e, r) {
            if (bloomFramebuffers.length < 2) return;
            let n = r;
            gl.disable(gl.BLEND), bloomPrefilterProgram.bind();
            let t = config.BLOOM_THRESHOLD * config.BLOOM_SOFT_KNEE + 1e-4,
                i = config.BLOOM_THRESHOLD - t,
                o = 2 * t,
                a = .25 / t;
            gl.uniform3f(bloomPrefilterProgram.uniforms.curve, i, o, a), gl.uniform1f(bloomPrefilterProgram.uniforms.threshold, config.BLOOM_THRESHOLD), gl.uniform1i(bloomPrefilterProgram.uniforms.uTexture, e.attach(0)), gl.viewport(0, 0, n.width, n.height), blit(n.fbo), bloomBlurProgram.bind();
            for (let e = 0; e < bloomFramebuffers.length; e++) {
                let r = bloomFramebuffers[e];
                gl.uniform2f(bloomBlurProgram.uniforms.texelSize, 1 / n.width, 1 / n.height), gl.uniform1i(bloomBlurProgram.uniforms.uTexture, n.attach(0)), gl.viewport(0, 0, r.width, r.height), blit(r.fbo), n = r
            }
            gl.blendFunc(gl.ONE, gl.ONE), gl.enable(gl.BLEND);
            for (let e = bloomFramebuffers.length - 2; e >= 0; e--) {
                let r = bloomFramebuffers[e];
                gl.uniform2f(bloomBlurProgram.uniforms.texelSize, 1 / n.width, 1 / n.height), gl.uniform1i(bloomBlurProgram.uniforms.uTexture, n.attach(0)), gl.viewport(0, 0, r.width, r.height), blit(r.fbo), n = r
            }
            gl.disable(gl.BLEND), bloomFinalProgram.bind(), gl.uniform2f(bloomFinalProgram.uniforms.texelSize, 1 / n.width, 1 / n.height), gl.uniform1i(bloomFinalProgram.uniforms.uTexture, n.attach(0)), gl.uniform1f(bloomFinalProgram.uniforms.intensity, config.BLOOM_INTENSITY), gl.viewport(0, 0, r.width, r.height), blit(r.fbo)
        }

        function splat(e, r, n, t, i) {
            gl.viewport(0, 0, simWidth, simHeight), splatProgram.bind(), gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0)), gl.uniform1f(splatProgram.uniforms.aspectRatio, canvas.width / canvas.height), gl.uniform2f(splatProgram.uniforms.point, e / canvas.width, 1 - r / canvas.height), gl.uniform3f(splatProgram.uniforms.color, n, -t, 1), gl.uniform1f(splatProgram.uniforms.radius, config.SPLAT_RADIUS / 100), blit(velocity.write.fbo), velocity.swap(), gl.viewport(0, 0, dyeWidth, dyeHeight), gl.uniform1i(splatProgram.uniforms.uTarget, density.read.attach(0)), gl.uniform3f(splatProgram.uniforms.color, i.r, i.g, i.b), blit(density.write.fbo), density.swap()
        }

        function multipleSplats(e) {
            for (let r = 0; r < e; r++) {
                const e = config.COLORFUL ? generateColor() : Object.assign({}, config.POINTER_COLOR.getRandom());
                e.r *= 10, e.g *= 10, e.b *= 10, splat(canvas.width * Math.random(), canvas.height * Math.random(), 1e3 * (Math.random() - .5), 1e3 * (Math.random() - .5), e)
            }
        }

        function resizeCanvas() {
            canvas.width == canvas.clientWidth && canvas.height == canvas.clientHeight || (canvas.width = canvas.clientWidth, canvas.height = canvas.clientHeight, initFramebuffers())
        }

        function generateColor() {
            let e = HSVtoRGB(Math.random(), 1, 1);
            return e.r *= .15, e.g *= .15, e.b *= .15, e
        }

        function HSVtoRGB(e, r, n) {
            let t, i, o, a, l, g, u, c;
            switch (g = n * (1 - r), u = n * (1 - (l = 6 * e - (a = Math.floor(6 * e))) * r), c = n * (1 - (1 - l) * r), a % 6) {
                case 0:
                    t = n, i = c, o = g;
                    break;
                case 1:
                    t = u, i = n, o = g;
                    break;
                case 2:
                    t = g, i = n, o = c;
                    break;
                case 3:
                    t = g, i = u, o = n;
                    break;
                case 4:
                    t = c, i = g, o = n;
                    break;
                case 5:
                    t = n, i = g, o = u
            }
            return {
                r: t,
                g: i,
                b: o
            }
        }

        function RGBToHue(e, r, n) {
            let t = Math.min(e, r, n),
                i = Math.max(e, r, n),
                o = i - t,
                a = 0;
            return a = 0 == o ? 0 : i == e ? (r - n) / o % 6 : i == r ? (n - e) / o + 2 : (e - r) / o + 4, (a = Math.round(60 * a)) < 0 && (a += 360), a
        }

        function getResolution(e) {
            let r = gl.drawingBufferWidth / gl.drawingBufferHeight;
            r < 1 && (r = 1 / r);
            let n = Math.round(e * r),
                t = Math.round(e);
            return gl.drawingBufferWidth > gl.drawingBufferHeight ? {
                width: n,
                height: t
            } : {
                width: t,
                height: n
            }
        }

        function getTextureScale(e, r, n) {
            return {
                x: r / e.width,
                y: n / e.height
            }
        }

        function rgbToPointerColor(e) {
            let r = e.split(" "),
                n = HSVtoRGB(RGBToHue(r[0], r[1], r[2]) / 360, 1, 1);
            return n.r *= .15, n.g *= .15, n.b *= .15, n
        }
        update(), canvas.addEventListener("mousemove", e => {
            pointers[0].moved = pointers[0].down, pointers[0].dx = 5 * (e.offsetX - pointers[0].x), pointers[0].dy = 5 * (e.offsetY - pointers[0].y), pointers[0].x = e.offsetX, pointers[0].y = e.offsetY
        }), canvas.addEventListener("touchmove", e => {
            e.preventDefault();
            const r = e.targetTouches;
            for (let e = 0; e < r.length; e++) {
                let n = pointers[e];
                n.moved = n.down, n.dx = 8 * (r[e].pageX - n.x), n.dy = 8 * (r[e].pageY - n.y), n.x = r[e].pageX, n.y = r[e].pageY
            }
        }, !1), canvas.addEventListener("mouseenter", () => {
            pointers[0].down = !0, pointers[0].color = config.POINTER_COLOR.getRandom()
        }), canvas.addEventListener("touchstart", e => {
            e.preventDefault();
            const r = e.targetTouches;
            for (let e = 0; e < r.length; e++) e >= pointers.length && pointers.push(new pointerPrototype), pointers[e].id = r[e].identifier, pointers[e].down = !0, pointers[e].x = r[e].pageX, pointers[e].y = r[e].pageY, pointers[e].color = config.POINTER_COLOR.getRandom()
        }), canvas.addEventListener("mousedown", () => {
            multipleSplats(parseInt(20 * Math.random()) + 5)
        }), window.addEventListener("mouseleave", () => {
            pointers[0].down = !1
        }), window.addEventListener("touchend", e => {
            const r = e.changedTouches;
            for (let e = 0; e < r.length; e++)
                for (let n = 0; n < pointers.length; n++) r[e].identifier == pointers[n].id && (pointers[n].down = !1)
        }), window.addEventListener("keydown", e => {
            "KeyP" === e.code && (config.PAUSED = !config.PAUSED), " " === e.key && splatStack.push(parseInt(20 * Math.random()) + 5)
        });
    </script>
</body>

{% endblock %}
